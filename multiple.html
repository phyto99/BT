<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <base href="./">
  <!-- Ensure proper scaling on all devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>N‑Back</title>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #000;
      --accent-color: #ffffff;
      --error-color: #d32f2f;
      --success-color: #27ae60;
      --text-color: #e0e0e0;
      --font: 'Roboto', sans-serif;
      --transition-speed: 0.3s;
      --shadow: 0 2px 8px rgba(0,0,0,0.3);
      --progress-bg: rgba(255, 255, 255, 0.2);
    }
    /* Global Reset */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    /* Ripple Effect on Buttons */
    button { position: relative; overflow: hidden; }
    .ripple {
      position: absolute;
      width: 20px;
      height: 20px;
      background: rgba(255,255,255,0.5);
      border-radius: 50%;
      transform: scale(0);
      animation: rippleEffect 600ms linear;
      pointer-events: none;
    }
    @keyframes rippleEffect { to { transform: scale(4); opacity: 0; } }
    
    /* Body */
    body {
      background: linear-gradient(135deg, #1a1a1a, #0a0a0a);
      font-family: var(--font);
      color: var(--text-color);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    
    /* INSTRUCTIONS PANEL */
    #instructions {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30,30,30,0.98);
      border: 2px solid var(--accent-color);
      padding: 20px 30px;
      max-width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      z-index: 100;
      text-align: left;
      box-shadow: var(--shadow);
    }
    #instructions h1 {
      text-align: center;
      margin-bottom: 15px;
      font-size: 2.4rem;
      color: var(--accent-color);
    }
    #instructions p { margin-bottom: 10px; line-height: 1.6; font-size: 1rem; }
    #instructions button {
      display: block;
      margin: 20px auto 0;
      padding: 12px 24px;
      font-size: 1rem;
      background: var(--accent-color);
      color: #000;
      border: none;
      cursor: pointer;
      transition: background var(--transition-speed);
    }
    #instructions button:hover { background: var(--success-color); }
    
    /* MAIN CONTAINER – full width to fit at 100% zoom */
    #container {
      display: none;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      gap: 20px;
      padding: 20px;
    }
    
    /* SETTINGS PANEL */
    #settings {
      flex: 1 1 250px;
      background: rgba(30,30,30,0.98);
      padding: 20px;
      border: 2px solid var(--accent-color);
      box-shadow: var(--shadow);
    }
    #settings h2 {
      text-align: center;
      margin-bottom: 15px;
      font-size: 1.8rem;
      color: var(--accent-color);
      border-bottom: 1px solid var(--accent-color);
      padding-bottom: 10px;
    }
    #settings label { display: block; margin-bottom: 5px; font-size: 0.9rem; }
    #settings input, #settings select, #settings button {
      width: 100%;
      padding: 10px;
      margin-bottom: 15px;
      border: none;
      font-size: 1rem;
    }
    #settings input, #settings select { background: #111; color: var(--text-color); }
    #settings button { background: var(--accent-color); color: #000; cursor: pointer; transition: background 0.3s; }
    #settings button:hover { background: var(--success-color); }
    
    /* SYNESTHESIA DICTIONARY PANEL */
    #synesthesiaDictionary {
      display: none;
      background: rgba(30,30,30,0.98);
      padding: 20px;
      border: 2px solid var(--accent-color);
      box-shadow: var(--shadow);
      max-width: 600px;
      width: 100%;
    }
    #synesthesiaDictionary h2 { text-align: center; margin-bottom: 15px; color: var(--accent-color); }
    #dictionaryList { max-height: 400px; overflow-y: auto; padding-right: 5px; }
    #dictionaryList div { display: flex; align-items: center; margin-bottom: 10px; }
    #dictionaryList .colorBox { width: 40px; height: 40px; margin-right: 10px; border: 1px solid #fff; }
    #dictionaryList button {
      padding: 6px 10px;
      font-size: 0.9rem;
      background: var(--accent-color);
      color: #000;
      border: none;
      cursor: pointer;
      transition: background 0.3s;
    }
    #dictionaryList button:hover { background: var(--success-color); }
    #returnSettings {
      width: 100%;
      padding: 10px;
      font-size: 1rem;
      background: var(--accent-color);
      color: #000;
      border: none;
      cursor: pointer;
      transition: background 0.3s;
    }
    #returnSettings:hover { background: var(--success-color); }
    
    /* GAME PANEL */
    #game {
      display: none;
      flex: 2 1 600px;
      background: rgba(10,10,10,0.85);
      border-radius: 10px;
      padding: 20px;
      border: 2px solid var(--accent-color);
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
      max-width: 100vw;
    }
    
    /* Circuit Overlay - removed, using solid background */
    #circuitOverlay {
      display: none;
    }
    
    /* Progress Bar and Trial Progress */
    #progressBarContainer {
      width: 100%;
      background: var(--progress-bg);
      border-radius: 5px;
      margin-bottom: 5px;
      overflow: hidden;
      z-index: 2;
    }
    #progressBar {
      height: 8px;
      width: 0%;
      background: var(--accent-color);
      transition: width 0.5s ease-out;
    }
    #trialProgress {
      font-size: 1.2rem;
      margin-bottom: 10px;
      text-align: center;
      color: var(--accent-color);
      z-index: 2;
    }
    
    /* Score Streak Display Repositioned Below Progress Info */
    #streakDisplay {
      font-size: 1.2rem;
      color: var(--success-color);
      z-index: 2;
      margin: 10px 0;
      text-align: center;
    }
    
    /* Grid */
    #grid {
      position: relative;
      z-index: 1;
      width: fit-content;
      margin: 0 auto 20px auto;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      border: 2px solid var(--accent-color);
    }
    .grid-cell {
      background: #000;
      border: 2px solid var(--accent-color);
      box-shadow: var(--shadow);
      position: relative;
    }
    
    /* Controls */
    #controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 15px;
    }
    #controls button {
      padding: 12px 24px;
      font-size: 1rem;
      background: var(--error-color);
      color: #fff;
      border: none;
      cursor: pointer;
      transition: background 0.3s;
    }
    #controls button:hover { background: #c62828; }
    #visualMatch { display: none; }
    #showDictionary {
      display: none;
      padding: 12px 24px;
      font-size: 1rem;
      background: var(--accent-color);
      color: #000;
      border: none;
      cursor: pointer;
      transition: background 0.3s;
      margin-top: 10px;
    }
    #showDictionary:hover { background: var(--success-color); }
    
    /* Score Display */
    #score {
      font-size: 1.4rem;
      font-weight: bold;
      padding: 10px 20px;
      background: #1a1a1a;
      border: 2px solid var(--accent-color);
      box-shadow: var(--shadow);
      transition: transform 0.2s;
    }
    @keyframes pop {
      0% { transform: scale(0.9); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    .score-pulse {
      animation: pop 0.6s ease-out;
    }
    
    /* RESULTS PANEL */
    #results {
      display: none;
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30,30,30,0.98);
      padding: 30px;
      border: 2px solid var(--accent-color);
      box-shadow: var(--shadow);
      text-align: center;
      max-width: 600px;
      width: 90%;
      z-index: 200;
    }
    #results h2 {
      font-size: 2rem;
      color: var(--accent-color);
      margin-bottom: 20px;
    }
    #results p {
      font-size: 1.2rem;
      margin-bottom: 20px;
      animation: bounce 1s ease;
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    
    /* Robot Container */
    #robotContainer {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 20px;
      flex-wrap: nowrap;
    }
    #robotImage { width: 120px; height: 180px; flex-shrink: 0; }
    #robotImage.happy { animation: happyNod 2s infinite; }
    @keyframes happyNod {
      0% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
      100% { transform: translateY(0); }
    }
    #robotImage.sad { animation: sadShake 2s infinite; }
    @keyframes sadShake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-3px); }
      50% { transform: translateX(3px); }
      75% { transform: translateX(-3px); }
      100% { transform: translateX(0); }
    }
    #robotText {
      flex-grow: 1;
      padding-left: 20px;
      text-align: left;
      background: var(--accent-color);
      color: #000;
      padding: 10px 15px;
      font-size: 1rem;
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      margin: 0;
      animation: fadeIn 0.5s ease-out;
    }
    
    /* Confetti */
    .confetti {
      position: absolute;
      width: 8px;
      height: 8px;
      opacity: 0.8;
      animation: confettiFall 2s linear forwards;
    }
    @keyframes confettiFall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(200px) rotate(360deg); opacity: 0; }
    }
    
    /* Pop Animation */
    .pop-animation { animation: pop 0.4s ease-out; }
    
    /* Glow Trail Effect */
    .glow-trail {
      position: absolute;
      background: radial-gradient(circle, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0) 70%);
      border-radius: 50%;
      pointer-events: none;
      transform: scale(1);
      animation: glowTrail 0.5s ease-out forwards;
    }
    @keyframes glowTrail {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(2.5); }
    }
    
    /* Fade In Animation */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Match Button Styling - Responsive like dichotic dual n-back */
    .corner-btn {
      position: fixed;
      text-align: center;
      background: rgba(128, 128, 128, 0.8);
      color: #fffff1;
      border: 1px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      transition: background 0.2s;
      user-select: none;
      -moz-user-select: none;
      -webkit-user-select: none;
      font-family: 'Roboto', sans-serif;
    }
    .corner-btn:hover {
      background: rgba(160, 160, 160, 0.9);
    }
    .corner-btn.correct {
      background: rgba(39, 174, 96, 0.9) !important;
      border-color: #27ae60;
      animation: correctPulse 0.5s ease;
    }
    .corner-btn.incorrect {
      background: rgba(231, 76, 60, 0.9) !important;
      border-color: #e74c3c;
      animation: incorrectShake 0.5s ease;
    }
    .corner-btn.missed {
      background: rgba(241, 196, 15, 0.9) !important;
      border-color: #f1c40f;
      animation: missedFlash 0.5s ease;
    }
    @keyframes correctPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    @keyframes incorrectShake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
    @keyframes missedFlash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* Portrait layout (mobile) */
    @media (orientation: portrait) {
      .corner-btn {
        width: 49svw;
        height: 10svh;
        line-height: 10svh;
        font-size: 4svh;
      }
      #positionMatch, #colorMatch {
        bottom: 11svh;
      }
      #knightMoveMatch, #takeMatch {
        bottom: 0.5svh;
      }
      #positionMatch, #knightMoveMatch {
        left: 0.5svw;
      }
      #colorMatch, #takeMatch {
        right: 0.5svw;
      }
      #positionMatch {
        border-top-right-radius: 4px;
        border-bottom-right-radius: 4px;
      }
      #colorMatch {
        border-top-left-radius: 4px;
        border-bottom-left-radius: 4px;
      }
      #knightMoveMatch {
        border-top-right-radius: 4px;
      }
      #takeMatch {
        border-top-left-radius: 4px;
      }
      #nBackMatch {
        bottom: 0.5svh;
        left: 0.5svw;
        right: 0.5svw;
        width: calc(100svw - 1svw);
        height: 10svh;
        line-height: 10svh;
      }
    }
    
    /* Landscape layout (desktop/tablet) */
    @media (orientation: landscape) {
      .corner-btn {
        width: 12svw;
        height: 22svh;
        line-height: 22svh;
        font-size: 3svh;
      }
      #positionMatch {
        top: 15svh;
        left: 1svw;
        border-top-right-radius: 4px;
        border-bottom-right-radius: 4px;
      }
      #knightMoveMatch {
        top: 38svh;
        left: 1svw;
        border-top-right-radius: 4px;
        border-bottom-right-radius: 4px;
      }
      #colorMatch {
        top: 15svh;
        right: 1svw;
        border-top-left-radius: 4px;
        border-bottom-left-radius: 4px;
      }
      #takeMatch {
        top: 38svh;
        right: 1svw;
        border-top-left-radius: 4px;
        border-bottom-left-radius: 4px;
      }
      #nBackMatch {
        bottom: 4svh;
        left: 50%;
        transform: translateX(-50%);
        width: 25svw;
        height: 12svh;
        line-height: 12svh;
        border-radius: 4px;
      }
    }
  </style>
</head>
<body>
  <!-- INSTRUCTIONS PANEL -->
  <div id="instructions">
    <h1>N‑Back</h1>
    <p>
      <strong>Modality Descriptions:</strong><br><br>
      <em>Gabor:</em> A Gabor patch appears in a random cell. Forced match trials repeat the orientation exactly from n‑back while appearing in a different cell.<br><br>
      <em>Circle (Knight’s Move):</em> A circle appears in a random cell. A match occurs if the current cell is reachable via a knight’s move from the n‑back cell. Additionally, in Circle mode you can press the "Visual Match" button to indicate an exact position match.<br><br>
      <em>Synesthesia:</em> Each trial randomly presents either a color or a sound. Twelve unique colors are paired with twelve distinct tone frequencies. N‑trials later, if the presented stimulus (regardless of modality) is the same as the one shown, that is a correct match.<br><br>
      <em>Relational Difference:</em> A number (0–99) is shown. For 1‑back, a match occurs if T(n) – T(n–1) = T(n–2) – T(n–3); for 2‑back, if T(n) – T(n–3) = T(n–2) – T(n–4).
    </p>
    <p>
      <strong>Instructions:</strong><br>
      Watch each stimulus carefully. When you believe the current stimulus matches the one shown n trials ago (according to the rules), press the "Match (n‑back)" button. In Circle mode you can also use the "Visual Match" button to indicate an exact position match. In Synesthesia mode, if the current stimulus (whether color or sound) corresponds to the one shown n trials ago, press "Match (n‑back)". Your score, progress, and current streak update automatically.
    </p>
    <button id="startInstructions">Begin</button>
  </div>
  
  <!-- MAIN CONTAINER -->
  <div id="container">
    <!-- SETTINGS PANEL -->
    <div id="settings">
      <h2>Settings</h2>
      <label for="modality">Select Modality:</label>
      <select id="modality">
        <option value="gabor">Gabor</option>
        <option value="circle">Circle (Knight’s Move)</option>
        <option value="synesthesia">Synesthesia</option>
        <option value="relational">Relational Difference</option>
      </select>
      <label for="nValue">N‑Back Value:</label>
      <input type="number" id="nValue" min="1" max="10" value="2">
      <label for="stimulusDuration">Stimulus Duration (ms):</label>
      <input type="number" id="stimulusDuration" min="100" max="2000" value="500">
      <label for="isiDuration">Inter‑Stimulus Interval (ms):</label>
      <input type="number" id="isiDuration" min="100" max="3000" value="1000">
      <div id="gaborParams">
        <label for="gaborContrast">Gabor Contrast (0 to 1):</label>
        <input type="range" id="gaborContrast" min="0" max="1" step="0.01" value="0.5">
        <label for="gaborFrequency">Gabor Spatial Frequency:</label>
        <input type="number" id="gaborFrequency" min="0.01" max="0.2" step="0.01" value="0.05">
      </div>
      <div id="relationalParams">
        <label for="relationalComplexity">Relational Complexity:</label>
        <select id="relationalComplexity">
          <option value="1back">1‑back</option>
          <option value="2back">2‑back</option>
        </select>
      </div>
      <label for="gaborSize">Stimulus Size (px):</label>
      <input type="number" id="gaborSize" min="50" max="300" value="150">
      <label for="totalTrials">Total Trials:</label>
      <input type="number" id="totalTrials" min="5" max="100" value="20">
      <button id="startTask">Start Task</button>
      <button id="showDictionary">Synesthesia Dictionary</button>
    </div>
    
    <!-- SYNESTHESIA DICTIONARY PANEL -->
    <div id="synesthesiaDictionary">
      <h2>Synesthesia Dictionary</h2>
      <div id="dictionaryList"></div>
      <button id="returnSettings">Return to Settings</button>
    </div>
    
    <!-- GAME PANEL -->
    <div id="game">
      <div id="circuitOverlay"></div>
      <div id="progressBarContainer">
        <div id="progressBar"></div>
      </div>
      <div id="trialProgress">Trial: 0 / 0</div>
      <!-- Score Streak Display -->
      <div id="streakDisplay">Streak: 0</div>
      <div id="grid">
        <canvas class="grid-cell" id="cell0"></canvas>
        <canvas class="grid-cell" id="cell1"></canvas>
        <canvas class="grid-cell" id="cell2"></canvas>
        <canvas class="grid-cell" id="cell3"></canvas>
        <canvas class="grid-cell" id="cell4"></canvas>
        <canvas class="grid-cell" id="cell5"></canvas>
        <canvas class="grid-cell" id="cell6"></canvas>
        <canvas class="grid-cell" id="cell7"></canvas>
        <canvas class="grid-cell" id="cell8"></canvas>
      </div>
      <div id="controls">
        <button id="restart">Restart</button>
        <button id="match" style="display: none;">Match (n‑back)</button>
        <button id="visualMatch" style="display: none;">Visual Match</button>
      </div>
      
      <!-- Circle Mode Corner Buttons -->
      <button id="positionMatch" class="corner-btn" style="display: none; z-index: 100;">Position (F)</button>
      <button id="colorMatch" class="corner-btn" style="display: none; z-index: 100;">Color (J)</button>
      <button id="knightMoveMatch" class="corner-btn" style="display: none; z-index: 100;">Knight (G)</button>
      <button id="takeMatch" class="corner-btn" style="display: none; z-index: 100;">Take (H)</button>
      
      <!-- Gabor/Synesthesia/Relational Mode Corner Button -->
      <button id="nBackMatch" class="corner-btn" style="display: none; z-index: 100;">Match (SPACE)</button>
      <div id="score">Score: 0</div>
    </div>
    
    <!-- RESULTS PANEL -->
    <div id="results">
      <div id="robotContainer">
        <div id="robotImage">
          <svg width="120" height="180" viewBox="0 0 120 180" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient id="robotBodyGradient1" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%" stop-color="#555" />
                <stop offset="100%" stop-color="#222" />
              </linearGradient>
            </defs>
            <g id="head">
              <ellipse cx="60" cy="40" rx="30" ry="28" fill="#777" stroke="#00ffea" stroke-width="2"/>
              <circle cx="50" cy="35" r="5" fill="#00f">
                <animate attributeName="opacity" values="1;0.3;1" dur="1.2s" repeatCount="indefinite"/>
              </circle>
              <circle cx="70" cy="35" r="5" fill="#00f">
                <animate attributeName="opacity" values="1;0.3;1" dur="1.2s" begin="0.6s" repeatCount="indefinite"/>
              </circle>
              <path d="M45,50 Q60,60 75,50" stroke="#00ffea" stroke-width="3" fill="none"/>
            </g>
            <g id="body">
              <path d="M25,75 Q60,120 95,75 L95,150 Q60,170 25,150 Z" fill="url(#robotBodyGradient1)" stroke="#00ffea" stroke-width="2"/>
            </g>
            <g id="arms">
              <line x1="25" y1="80" x2="5" y2="110" stroke="#00ffea" stroke-width="3"/>
              <line x1="95" y1="80" x2="115" y2="110" stroke="#00ffea" stroke-width="3"/>
            </g>
            <g id="legs">
              <rect x="40" y="150" width="15" height="25" fill="#777" stroke="#00ffea" stroke-width="2"/>
              <rect x="65" y="150" width="15" height="25" fill="#777" stroke="#00ffea" stroke-width="2"/>
            </g>
            <line x1="60" y1="10" x2="60" y2="30" stroke="#00ffea" stroke-width="2"/>
            <circle cx="60" cy="10" r="4" fill="#00ffea"/>
          </svg>
        </div>
        <div id="robotText">Great job!</div>
      </div>
      <h2>Task Complete!</h2>
      <p id="resultMessage"></p>
      <button id="playAgain">Play Again</button>
    </div>
  </div>
  
  <script>
    // Preload knight images
    const whiteKnight = new Image();
    const blackKnight = new Image();
    
    whiteKnight.src = 'wn.png';
    blackKnight.src = 'bn.png';
    
    // Global Variables and Arrays
    let audioCtx = null;
    const toneFrequencies = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25, 587.33, 659.25, 739.99, 783.99];
    const synesthesiaColors = ["#FF0000", "#FF7F00", "#FFFF00", "#00FF00", "#00BFFF", "#0000FF", "#4B0082", "#8A2BE2", "#FF00FF", "#FFD700", "#FF1493", "#6A5ACD"];
    
    document.addEventListener("DOMContentLoaded", updateAdditionalParams);
    function updateAdditionalParams() {
      const mod = document.getElementById("modality").value;
      document.getElementById("gaborParams").style.display = (mod === "gabor") ? "block" : "none";
      document.getElementById("relationalParams").style.display = (mod === "relational") ? "block" : "none";
      document.getElementById("visualMatch").style.display = "none"; // Hide old button
      
      // Show/hide circle mode buttons
      const showCircle = (mod === "circle") ? "block" : "none";
      document.getElementById("positionMatch").style.display = showCircle;
      document.getElementById("colorMatch").style.display = showCircle;
      document.getElementById("knightMoveMatch").style.display = showCircle;
      document.getElementById("takeMatch").style.display = showCircle;
      
      // Show/hide corner n-back button for non-circle modes
      const showNBack = (mod !== "circle") ? "block" : "none";
      document.getElementById("nBackMatch").style.display = showNBack;
      
      // Hide old match button in controls
      document.getElementById("match").style.display = "none";
      
      document.getElementById("showDictionary").style.display = (mod === "synesthesia") ? "inline-block" : "none";
    }
    
    function fadeIn(element) {
      element.style.opacity = 0;
      element.style.display = (element.id === "container") ? "flex" : "block";
      requestAnimationFrame(() => {
        element.style.transition = "opacity 0.5s ease";
        element.style.opacity = 1;
      });
    }
    function fadeOut(element) {
      element.style.transition = "opacity 0.5s ease";
      element.style.opacity = 0;
      setTimeout(() => {
        element.style.display = "none";
        element.style.transition = "";
      }, 500);
    }
    
    
    document.querySelectorAll("button").forEach(button => {
      button.addEventListener("click", function(e) {
        let ripple = document.createElement("span");
        ripple.className = "ripple";
        this.appendChild(ripple);
        const rect = this.getBoundingClientRect();
        ripple.style.left = (e.clientX - rect.left) + "px";
        ripple.style.top = (e.clientY - rect.top) + "px";
        setTimeout(() => { ripple.remove(); }, 600);
      });
    });
    
    let currentTrial = 0;
    let trialsData = [];
    let score = 0;
    let isRunning = false;
    let responseRecorded = false;
    let currentTrialData = null;
    let settings = {};
    let gridCanvases = [];
    let cellContexts = {};
    let stimulusTimeout = null;
    let trialTimeout = null;
    let currentStreak = 0;
    
    // Circle mode scoring
    let circleScores = {
      position: { correct: 0, total: 0 },
      color: { correct: 0, total: 0 },
      knightMove: { correct: 0, total: 0 },
      take: { correct: 0, total: 0 }
    };
    
    // For improved statistics, record "matchTrial" on match-intended trials.
    function computePossibleMatches() {
      let count = 0;
      for (let i = settings.nValue; i < trialsData.length; i++) {
        if (trialsData[i].matchTrial === true) count++;
      }
      return count;
    }
    
    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function getRandomIntNotEqual(min, max, exclude) {
      let rand;
      do { rand = getRandomInt(min, max); } while(rand === exclude);
      return rand;
    }
    
    // Glow trail effect for a grid cell
    function createGlowTrail(cell) {
      const trail = document.createElement("div");
      trail.className = "glow-trail";
      const gameRect = document.getElementById("game").getBoundingClientRect();
      const cellRect = cell.getBoundingClientRect();
      trail.style.width = cellRect.width + "px";
      trail.style.height = cellRect.height + "px";
      trail.style.top = (cellRect.top - gameRect.top) + "px";
      trail.style.left = (cellRect.left - gameRect.left) + "px";
      document.getElementById("game").appendChild(trail);
      setTimeout(() => { trail.remove(); }, 500);
    }
    
    function startTask() {
      settings = {
        modality: document.getElementById("modality").value,
        nValue: parseInt(document.getElementById("nValue").value),
        stimulusDuration: parseInt(document.getElementById("stimulusDuration").value),
        isiDuration: parseInt(document.getElementById("isiDuration").value),
        gaborContrast: parseFloat(document.getElementById("gaborContrast").value),
        gaborFrequency: parseFloat(document.getElementById("gaborFrequency").value),
        gaborSize: parseInt(document.getElementById("gaborSize").value),
        totalTrials: parseInt(document.getElementById("totalTrials").value)
      };
      if (settings.modality === "relational") {
        settings.relationalComplexity = document.getElementById("relationalComplexity").value;
      }
      gridCanvases = document.querySelectorAll(".grid-cell");
      gridCanvases.forEach(canvas => {
        canvas.width = settings.gaborSize;
        canvas.height = settings.gaborSize;
        cellContexts[canvas.id] = canvas.getContext("2d");
        canvas.style.borderColor = "#ffffff";
        canvas.style.backgroundColor = "#000";
      });
      document.getElementById("settings").style.display = "none";
      document.getElementById("synesthesiaDictionary").style.display = "none";
      document.getElementById("results").style.display = "none";
      document.getElementById("game").style.display = "flex";
      
      // Update button visibility based on modality
      updateAdditionalParams();
      
      // Reset streak
      currentStreak = 0;
      updateStreakDisplay();
      
      currentTrial = 0;
      trialsData = [];
      score = 0;
      isRunning = true;
      
      // Reset circle mode scores
      circleScores = {
        position: { correct: 0, total: 0 },
        color: { correct: 0, total: 0 },
        knightMove: { correct: 0, total: 0 },
        take: { correct: 0, total: 0 }
      };
      responseRecorded = false;
      currentTrialData = null;
      clearTimeout(stimulusTimeout);
      clearTimeout(trialTimeout);
      stimulusTimeout = null;
      trialTimeout = null;
      document.getElementById("score").textContent = "Score: 0";
      updateProgressBar();
      if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
      
      // Wait a moment for images to load before starting
      setTimeout(() => {
        nextTrial();
      }, 100);
    }
    
    function updateStreakDisplay() {
      document.getElementById("streakDisplay").textContent = "Streak: " + currentStreak;
    }
    
    function updateProgressBar() {
      const progressBar = document.getElementById("progressBar");
      const percentage = (currentTrial / settings.totalTrials) * 100;
      progressBar.style.width = percentage + "%";
      document.getElementById("trialProgress").textContent = `Trial: ${currentTrial + 1} / ${settings.totalTrials}`;
    }
    
    function clearGrid() {
      gridCanvases.forEach(canvas => {
        let ctx = cellContexts[canvas.id];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      });
    }
    
    function nextTrial() {
      if (!isRunning) return;
      updateProgressBar();
      if (settings.modality === "gabor") nextTrialGabor();
      else if (settings.modality === "circle") nextTrialCircle();
      else if (settings.modality === "synesthesia") nextTrialSynesthesia();
      else if (settings.modality === "relational") nextTrialRelational();
    }
    
    function nextTrialGabor() {
      if (currentTrial >= settings.totalTrials) { endTask(); return; }
      clearTimeout(stimulusTimeout);
      clearTimeout(trialTimeout);
      clearGrid();
      let trial = {};
      if (currentTrial < settings.nValue) {
        trial.isMatch = false;
        trial.matchTrial = false;
        trial.cell = getRandomInt(0, 8);
        trial.orientation = Math.random() * 360;
      } else {
        let nBack = trialsData[currentTrial - settings.nValue];
        if (Math.random() < 0.40) {
          trial.isMatch = true;
          trial.matchTrial = true;
          trial.orientation = nBack.orientation;
          trial.cell = getRandomIntNotEqual(0, 8, nBack.cell);
        } else {
          trial.isMatch = false;
          trial.matchTrial = false;
          trial.orientation = Math.random() * 360;
          trial.cell = getRandomInt(0, 8);
        }
      }
      trialsData.push(trial);
      currentTrialData = trial;
      let canvas = document.getElementById("cell" + trial.cell);
      let ctx = cellContexts[canvas.id];
      drawGaborPatch(ctx, settings.gaborSize, settings.gaborSize, trial.orientation, settings.gaborContrast, settings.gaborFrequency);
      createGlowTrail(canvas);
      responseRecorded = false;
      canvas.classList.add("pop-animation");
      setTimeout(() => { canvas.classList.remove("pop-animation"); }, 400);
      stimulusTimeout = setTimeout(() => { clearGrid(); }, settings.stimulusDuration);
      trialTimeout = setTimeout(() => { currentTrial++; nextTrial(); }, settings.stimulusDuration + settings.isiDuration);
    }
    
    function nextTrialCircle() {
      if (currentTrial >= settings.totalTrials) { endTask(); return; }
      
      // Check for missed matches from previous trial
      if (currentTrial > 0) {
        checkMissedMatches();
      }
      
      clearTimeout(stimulusTimeout);
      clearTimeout(trialTimeout);
      clearGrid();
      circleResponses = {}; // Reset responses for new trial
      
      let trial = {};
      trial.cell = getRandomInt(0, 8);
      trial.color = Math.random() < 0.5 ? 'white' : 'black';
      
      // Calculate match types if we have n-back history
      if (currentTrial >= settings.nValue) {
        let nBack = trialsData[currentTrial - settings.nValue];
        trial.positionMatch = (trial.cell === nBack.cell);
        trial.colorMatch = (trial.color === nBack.color);
        trial.knightMoveMatch = isKnightMove(nBack.cell, trial.cell) && trial.color === nBack.color;
        trial.takeMatch = isKnightMove(nBack.cell, trial.cell) && trial.color !== nBack.color;
      } else {
        trial.positionMatch = false;
        trial.colorMatch = false;
        trial.knightMoveMatch = false;
        trial.takeMatch = false;
      }
      
      trialsData.push(trial);
      currentTrialData = trial;
      let canvas = document.getElementById("cell" + trial.cell);
      let ctx = cellContexts[canvas.id];
      drawCircle(ctx, settings.gaborSize, settings.gaborSize, trial.color);
      createGlowTrail(canvas);
      responseRecorded = false;
      canvas.classList.add("pop-animation");
      setTimeout(() => { canvas.classList.remove("pop-animation"); }, 400);
      stimulusTimeout = setTimeout(() => { clearGrid(); }, settings.stimulusDuration);
      trialTimeout = setTimeout(() => { currentTrial++; nextTrial(); }, settings.stimulusDuration + settings.isiDuration);
    }
    
    function nextTrialSynesthesia() {
      if (currentTrial >= settings.totalTrials) { endTask(); return; }
      clearTimeout(stimulusTimeout);
      clearTimeout(trialTimeout);
      clearGrid();
      let trial = {};
      trial.index = getRandomInt(0, 11);
      trial.stimulusType = (Math.random() < 0.5) ? "visual" : "auditory";
      if (currentTrial < settings.nValue) { trial.isMatch = false; trial.matchTrial = false; }
      else {
        let nBack = trialsData[currentTrial - settings.nValue];
        if (Math.random() < 0.40) { trial.isMatch = true; trial.matchTrial = true; trial.index = nBack.index; }
        else { trial.isMatch = false; trial.matchTrial = false; }
      }
      trialsData.push(trial);
      currentTrialData = trial;
      trial.cell = getRandomInt(0, 8);
      let canvas = document.getElementById("cell" + trial.cell);
      let ctx = cellContexts[canvas.id];
      if (trial.stimulusType === "visual") {
        ctx.fillStyle = synesthesiaColors[trial.index];
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        playTone(toneFrequencies[trial.index], settings.stimulusDuration);
      }
      createGlowTrail(canvas);
      responseRecorded = false;
      canvas.classList.add("pop-animation");
      setTimeout(() => { canvas.classList.remove("pop-animation"); }, 400);
      stimulusTimeout = setTimeout(() => { clearGrid(); }, settings.stimulusDuration);
      trialTimeout = setTimeout(() => { currentTrial++; nextTrial(); }, settings.stimulusDuration + settings.isiDuration);
    }
    
    function nextTrialRelational() {
      if (currentTrial >= settings.totalTrials) { endTask(); return; }
      clearTimeout(stimulusTimeout);
      clearTimeout(trialTimeout);
      clearGrid();
      let trial = {};
      if (settings.relationalComplexity === "1back") {
        if (currentTrial < settings.nValue + 1) { trial.isMatch = false; trial.matchTrial = false; trial.number = getRandomInt(0, 99); }
        else {
          if (Math.random() < 0.40) {
            trial.isMatch = true;
            trial.matchTrial = true;
            let computed = trialsData[currentTrial - 1].number + (trialsData[currentTrial - 2].number - trialsData[currentTrial - 3].number);
            computed = ((computed % 100) + 100) % 100;
            trial.number = computed;
          } else { trial.isMatch = false; trial.matchTrial = false; trial.number = getRandomInt(0, 99); }
        }
      } else if (settings.relationalComplexity === "2back") {
        if (currentTrial < settings.nValue + 2) { trial.isMatch = false; trial.matchTrial = false; trial.number = getRandomInt(0, 99); }
        else {
          if (Math.random() < 0.40) {
            trial.isMatch = true;
            trial.matchTrial = true;
            let computed = trialsData[currentTrial - 3].number + (trialsData[currentTrial - 2].number - trialsData[currentTrial - 4].number);
            computed = ((computed % 100) + 100) % 100;
            trial.number = computed;
          } else { trial.isMatch = false; trial.matchTrial = false; trial.number = getRandomInt(0, 99); }
        }
      }
      trial.cell = getRandomInt(0, 8);
      trialsData.push(trial);
      currentTrialData = trial;
      let canvas = document.getElementById("cell" + trial.cell);
      let ctx = cellContexts[canvas.id];
      ctx.fillStyle = "#ffffff";
      ctx.font = (settings.gaborSize * 0.8) + "px Roboto, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(trial.number, canvas.width / 2, canvas.height / 2);
      createGlowTrail(canvas);
      responseRecorded = false;
      canvas.classList.add("pop-animation");
      setTimeout(() => { canvas.classList.remove("pop-animation"); }, 400);
      stimulusTimeout = setTimeout(() => { clearGrid(); }, settings.stimulusDuration);
      trialTimeout = setTimeout(() => { currentTrial++; nextTrial(); }, settings.stimulusDuration + settings.isiDuration);
    }
    
    function playTone(frequency, duration) {
      if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
      if (audioCtx.state === "suspended") audioCtx.resume();
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.frequency.value = frequency;
      oscillator.type = "sine";
      gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + 0.01);
      gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime + (duration/1000) - 0.05);
      gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + (duration/1000));
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + (duration/1000) + 0.1);
    }
    
    function drawGaborPatch(ctx, width, height, orientation, contrast, frequency) {
      let imageData = ctx.createImageData(width, height);
      let data = imageData.data;
      let cx = width / 2, cy = height / 2;
      let sigma = width / 6;
      let theta = orientation * Math.PI / 180;
      for (let y = 0; y < height; y++){
        for (let x = 0; x < width; x++){
          let x0 = x - cx, y0 = y - cy;
          let xr = x0 * Math.cos(theta) + y0 * Math.sin(theta);
          let grating = Math.cos(2 * Math.PI * frequency * xr);
          let gaussian = Math.exp(- (x0 * x0 + y0 * y0) / (2 * sigma * sigma));
          let value = contrast * grating * gaussian;
          let intensity = Math.round(128 + value * 127);
          let index = (y * width + x) * 4;
          data[index] = intensity;
          data[index+1] = intensity;
          data[index+2] = intensity;
          data[index+3] = 255;
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }
    
    function drawCircle(ctx, width, height, color) {
      // Use specified color or random if not provided
      const knightImage = color === 'white' ? whiteKnight : (color === 'black' ? blackKnight : (Math.random() < 0.5 ? whiteKnight : blackKnight));
      let size = width * 0.6; // Fixed size: 60% of cell width
      let x = width/2 - size/2;
      let y = height/2 - size/2;
      
      ctx.drawImage(knightImage, x, y, size, size);
      return knightImage === whiteKnight ? 'white' : 'black';
    }
    
    function drawSynesthesiaStimulus(ctx, width, height, color) {
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, width, height);
    }
    
    function addPopAnimation(canvas) {
      canvas.classList.add("pop-animation");
      setTimeout(() => { canvas.classList.remove("pop-animation"); }, 400);
    }
    
    function pulseScore() {
      let scoreEl = document.getElementById("score");
      scoreEl.classList.add("score-pulse");
      setTimeout(() => { scoreEl.classList.remove("score-pulse"); }, 600);
    }
    
    function playCorrectSound() {
      if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      osc.frequency.value = 800;
      osc.type = "sine";
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    }
    function playIncorrectSound() {
      if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      osc.frequency.value = 300;
      osc.type = "sine";
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    }
    
    function handleMatch() {
      if (responseRecorded || currentTrialData === null) return;
      responseRecorded = true;
      let feedbackCell = currentTrialData.cell;
      let correct = false;
      if (settings.modality === "gabor") {
        if (currentTrial >= settings.nValue) {
          if (currentTrialData.isMatch === true) correct = true;
        }
      } else {
        if (currentTrialData.isMatch === true) correct = true;
      }
      if (correct) {
        score++;
        currentStreak++;
        flashCell(feedbackCell, "#27ae60");
        pulseScore();
        if (settings.modality !== "synesthesia") { playCorrectSound(); }
      } else {
        currentStreak = 0;
        flashCell(feedbackCell, "#ff2d95");
        if (settings.modality !== "synesthesia") { playIncorrectSound(); }
      }
      updateStreakDisplay();
      document.getElementById("score").textContent = "Score: " + score;
    }
    
    function handleNBackMatch() {
      if (responseRecorded || currentTrialData === null) return;
      if (settings.modality === "circle") return; // Circle mode uses different handlers
      
      responseRecorded = true;
      let feedbackCell = currentTrialData.cell;
      let correct = false;
      let button = document.getElementById("nBackMatch");
      
      if (settings.modality === "gabor") {
        if (currentTrial >= settings.nValue) {
          if (currentTrialData.isMatch === true) correct = true;
        }
      } else {
        if (currentTrialData.isMatch === true) correct = true;
      }
      
      if (correct) {
        score++;
        currentStreak++;
        flashCell(feedbackCell, "#27ae60");
        pulseScore();
        if (settings.modality !== "synesthesia") { playCorrectSound(); }
        button.classList.add('correct');
        setTimeout(() => button.classList.remove('correct'), 500);
      } else {
        currentStreak = 0;
        flashCell(feedbackCell, "#ff2d95");
        if (settings.modality !== "synesthesia") { playIncorrectSound(); }
        button.classList.add('incorrect');
        setTimeout(() => button.classList.remove('incorrect'), 500);
      }
      updateStreakDisplay();
      document.getElementById("score").textContent = "Score: " + score;
    }
    
    function handleVisualMatch() {
      if (document.getElementById("modality").value !== "circle") return;
      if (responseRecorded || currentTrialData === null) return;
      responseRecorded = true;
      let nBack = trialsData[currentTrial - settings.nValue];
      let feedbackCell = currentTrialData.cell;
      let correct = false;
      if (currentTrial >= settings.nValue && currentTrialData.cell === nBack.cell) correct = true;
      if (correct) {
        score++;
        currentStreak++;
        flashCell(feedbackCell, "#27ae60");
        pulseScore();
        if (settings.modality !== "synesthesia") { playCorrectSound(); }
      } else {
        currentStreak = 0;
        flashCell(feedbackCell, "#ff2d95");
        if (settings.modality !== "synesthesia") { playIncorrectSound(); }
      }
      updateStreakDisplay();
      document.getElementById("score").textContent = "Score: " + score;
    }
    
    let circleResponses = {}; // Track responses for current trial
    
    function handleCircleMatch(matchType) {
      if (settings.modality !== "circle") return;
      if (!currentTrialData || currentTrial < settings.nValue) return;
      if (circleResponses[matchType]) return; // Already responded to this match type
      
      circleResponses[matchType] = true;
      
      let correct = false;
      let buttonId = '';
      if (matchType === 'position') { correct = currentTrialData.positionMatch; buttonId = 'positionMatch'; }
      else if (matchType === 'color') { correct = currentTrialData.colorMatch; buttonId = 'colorMatch'; }
      else if (matchType === 'knightMove') { correct = currentTrialData.knightMoveMatch; buttonId = 'knightMoveMatch'; }
      else if (matchType === 'take') { correct = currentTrialData.takeMatch; buttonId = 'takeMatch'; }
      
      let button = document.getElementById(buttonId);
      let feedbackCell = currentTrialData.cell;
      
      if (correct) {
        circleScores[matchType].correct++;
        score++;
        currentStreak++;
        flashCell(feedbackCell, "#27ae60");
        pulseScore();
        playCorrectSound();
        button.classList.add('correct');
        setTimeout(() => button.classList.remove('correct'), 500);
      } else {
        currentStreak = 0;
        flashCell(feedbackCell, "#ff2d95");
        playIncorrectSound();
        button.classList.add('incorrect');
        setTimeout(() => button.classList.remove('incorrect'), 500);
      }
      updateStreakDisplay();
      document.getElementById("score").textContent = "Score: " + score;
    }
    
    function checkMissedMatches() {
      if (settings.modality !== "circle" || !currentTrialData || currentTrial < settings.nValue) return;
      
      // Check for missed matches and update totals
      const matchTypes = ['position', 'color', 'knightMove', 'take'];
      const buttonIds = ['positionMatch', 'colorMatch', 'knightMoveMatch', 'takeMatch'];
      
      for (let i = 0; i < matchTypes.length; i++) {
        const matchType = matchTypes[i];
        const buttonId = buttonIds[i];
        let wasMatch = false;
        
        if (matchType === 'position') wasMatch = currentTrialData.positionMatch;
        else if (matchType === 'color') wasMatch = currentTrialData.colorMatch;
        else if (matchType === 'knightMove') wasMatch = currentTrialData.knightMoveMatch;
        else if (matchType === 'take') wasMatch = currentTrialData.takeMatch;
        
        if (wasMatch) {
          circleScores[matchType].total++;
          if (!circleResponses[matchType]) {
            // Missed a match
            let button = document.getElementById(buttonId);
            button.classList.add('missed');
            setTimeout(() => button.classList.remove('missed'), 500);
          }
        }
      }
    }
    
    document.getElementById("match").addEventListener("click", handleMatch);
    document.getElementById("visualMatch").addEventListener("click", handleVisualMatch);
    
    // Circle mode multi-modal match handlers
    document.getElementById("positionMatch").addEventListener("click", () => handleCircleMatch('position'));
    document.getElementById("colorMatch").addEventListener("click", () => handleCircleMatch('color'));
    document.getElementById("knightMoveMatch").addEventListener("click", () => handleCircleMatch('knightMove'));
    document.getElementById("takeMatch").addEventListener("click", () => handleCircleMatch('take'));
    
    // N-back match handler for non-circle modes
    document.getElementById("nBackMatch").addEventListener("click", handleNBackMatch);
    
    // Keyboard shortcuts
    document.addEventListener("keydown", (e) => {
      if (!isRunning) return;
      
      if (settings.modality === "circle") {
        // Circle mode shortcuts
        if (e.key === 'f' || e.key === 'F') handleCircleMatch('position');
        else if (e.key === 'j' || e.key === 'J') handleCircleMatch('color');
        else if (e.key === 'g' || e.key === 'G') handleCircleMatch('knightMove');
        else if (e.key === 'h' || e.key === 'H') handleCircleMatch('take');
      } else {
        // Other modes: spacebar for n-back match
        if (e.key === ' ' || e.key === 'Spacebar') {
          e.preventDefault();
          handleNBackMatch();
        }
      }
    });
    
    function endTask() {
      isRunning = false;
      document.getElementById("game").style.display = "none";
      const resultsEl = document.getElementById("results");
      
      let resultsHTML = '';
      let accuracyValue = 0;
      
      if (settings.modality === "circle") {
        // Circle mode: show detailed breakdown
        const posAcc = circleScores.position.total > 0 ? Math.round((circleScores.position.correct / circleScores.position.total) * 100) : 0;
        const colAcc = circleScores.color.total > 0 ? Math.round((circleScores.color.correct / circleScores.color.total) * 100) : 0;
        const knightAcc = circleScores.knightMove.total > 0 ? Math.round((circleScores.knightMove.correct / circleScores.knightMove.total) * 100) : 0;
        const takeAcc = circleScores.take.total > 0 ? Math.round((circleScores.take.correct / circleScores.take.total) * 100) : 0;
        
        accuracyValue = (posAcc + colAcc + knightAcc + takeAcc) / 4;
        
        resultsHTML = `
          <h2>Task Complete!</h2>
          <div style="font-size: 1.2rem; margin-bottom: 20px; line-height: 1.8; text-align: left; max-width: 500px; margin-left: auto; margin-right: auto;">
            <div>Your score: ${circleScores.position.correct} out of ${circleScores.position.total} position matches</div>
            <div style="padding-left: 95px;">${circleScores.color.correct} out of ${circleScores.color.total} color matches</div>
            <div style="padding-left: 95px;">${circleScores.knightMove.correct} out of ${circleScores.knightMove.total} knight move matches</div>
            <div style="padding-left: 95px;">${circleScores.take.correct} out of ${circleScores.take.total} take matches</div>
          </div>
          <p style="font-size: 1.3rem; font-weight: bold;">
            Accuracy: ${posAcc}% ${colAcc}% ${knightAcc}% ${takeAcc}%
          </p>
        `;
      } else {
        // Other modes: show standard results
        let possibleMatches = computePossibleMatches();
        accuracyValue = possibleMatches > 0 ? (score / possibleMatches) * 100 : 0;
        let accuracyPercentage = possibleMatches > 0 ? accuracyValue.toFixed(0) : "N/A";
        resultsHTML = `
          <h2>Task Complete!</h2>
          <p>Your Score: ${score} out of ${possibleMatches} possible matches.</p>
          <p>Accuracy: ${accuracyPercentage}%</p>
        `;
      }
      
      const robotImage = document.getElementById("robotImage");
      robotImage.classList.remove("happy", "sad");
      if (accuracyValue >= 70) { robotImage.classList.add("happy"); }
      else if (accuracyValue < 40) { robotImage.classList.add("sad"); }
      let message = getEncouragement(accuracyValue);
      
      resultsEl.innerHTML = `
        <div id="robotContainer">
          <div id="robotImage">
            <svg width="120" height="180" viewBox="0 0 120 180" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <linearGradient id="robotBodyGradient2" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="0%" stop-color="#555" />
                  <stop offset="100%" stop-color="#222" />
                </linearGradient>
              </defs>
              <g id="head">
                <ellipse cx="60" cy="40" rx="30" ry="28" fill="#777" stroke="#00ffea" stroke-width="2"/>
                <circle cx="50" cy="35" r="5" fill="#00f">
                  <animate attributeName="opacity" values="1;0.3;1" dur="1.2s" repeatCount="indefinite"/>
                </circle>
                <circle cx="70" cy="35" r="5" fill="#00f">
                  <animate attributeName="opacity" values="1;0.3;1" dur="1.2s" begin="0.6s" repeatCount="indefinite"/>
                </circle>
                <path d="M45,50 Q60,60 75,50" stroke="#00ffea" stroke-width="3" fill="none"/>
              </g>
              <g id="body">
                <path d="M25,75 Q60,120 95,75 L95,150 Q60,170 25,150 Z" fill="url(#robotBodyGradient2)" stroke="#00ffea" stroke-width="2"/>
              </g>
              <g id="arms">
                <line x1="25" y1="80" x2="5" y2="110" stroke="#00ffea" stroke-width="3"/>
                <line x1="95" y1="80" x2="115" y2="110" stroke="#00ffea" stroke-width="3"/>
              </g>
              <g id="legs">
                <rect x="40" y="150" width="15" height="25" fill="#777" stroke="#00ffea" stroke-width="2"/>
                <rect x="65" y="150" width="15" height="25" fill="#777" stroke="#00ffea" stroke-width="2"/>
              </g>
              <line x1="60" y1="10" x2="60" y2="30" stroke="#00ffea" stroke-width="2"/>
              <circle cx="60" cy="10" r="4" fill="#00ffea"/>
            </svg>
          </div>
          <div id="robotText">${message}</div>
        </div>
        ${resultsHTML}
        <button id="playAgain">Play Again</button>
      `;
      resultsEl.style.display = "block";
      document.getElementById("playAgain").addEventListener("click", restartTask);
      if (accuracyValue >= 70) launchConfetti();
    }
    
    function getEncouragement(accuracy) {
      let highMessages = ["Outstanding! You're a genius!", "Amazing performance!", "Incredible!"];
      let mediumMessages = ["Great job! Keep pushing!", "Well done!", "Nice work!"];
      let lowMessages = ["Keep trying!", "Don't worry, practice makes perfect!", "You'll get there!"];
      if (accuracy >= 70) return highMessages[getRandomInt(0, highMessages.length - 1)];
      else if (accuracy >= 40) return mediumMessages[getRandomInt(0, mediumMessages.length - 1)];
      else return lowMessages[getRandomInt(0, lowMessages.length - 1)];
    }
    
    function launchConfetti() {
      const resultsEl = document.getElementById("results");
      let confettiContainer = document.createElement("div");
      confettiContainer.id = "confettiContainer";
      confettiContainer.style.position = "absolute";
      confettiContainer.style.top = "0";
      confettiContainer.style.left = "0";
      confettiContainer.style.width = "100%";
      confettiContainer.style.height = "100%";
      confettiContainer.style.pointerEvents = "none";
      resultsEl.appendChild(confettiContainer);
      const confettiCount = 20;
      for (let i = 0; i < confettiCount; i++) {
        let confetti = document.createElement("div");
        confetti.className = "confetti";
        confetti.style.left = Math.random() * 100 + "%";
        confetti.style.animationDelay = Math.random() * 0.5 + "s";
        const confettiColors = ["#FF7F00", "#FFFF00", "#00FF00", "#00BFFF", "#FF00FF", "#FFD700"];
        confetti.style.backgroundColor = confettiColors[getRandomInt(0, confettiColors.length - 1)];
        confettiContainer.appendChild(confetti);
      }
      setTimeout(() => { resultsEl.removeChild(confettiContainer); }, 3000);
    }
    
    function flashCell(cellIndex, color) {
      let canvas = document.getElementById("cell" + cellIndex);
      canvas.style.borderColor = color;
      setTimeout(() => { canvas.style.borderColor = "#ffffff"; }, 300);
    }
    
    function restartTask() {
      isRunning = false;
      currentTrial = 0;
      trialsData = [];
      score = 0;
      currentStreak = 0;
      updateStreakDisplay();
      document.getElementById("score").textContent = "Score: 0";
      document.getElementById("synesthesiaDictionary").style.display = "none";
      document.getElementById("game").style.display = "none";
      document.getElementById("results").style.display = "none";
      document.getElementById("settings").style.display = "block";
      updateAdditionalParams();
      clearGrid();
      clearTimeout(stimulusTimeout);
      clearTimeout(trialTimeout);
      stimulusTimeout = null;
      trialTimeout = null;
    }
    
    document.getElementById("startInstructions").addEventListener("click", () => {
      fadeOut(document.getElementById("instructions"));
      fadeIn(document.getElementById("container"));
      fadeIn(document.getElementById("settings"));
      document.getElementById("game").style.display = "none";
      document.getElementById("results").style.display = "none";
      updateAdditionalParams();
    });
    document.getElementById("startTask").addEventListener("click", startTask);
    document.getElementById("restart").addEventListener("click", restartTask);
    document.getElementById("match").addEventListener("click", handleMatch);
    document.getElementById("playAgain").addEventListener("click", restartTask);
    document.getElementById("modality").addEventListener("change", updateAdditionalParams);
    document.getElementById("showDictionary").addEventListener("click", () => {
      fadeOut(document.getElementById("settings"));
      fadeIn(document.getElementById("synesthesiaDictionary"));
      populateDictionary();
    });
    document.getElementById("returnSettings").addEventListener("click", () => {
      fadeOut(document.getElementById("synesthesiaDictionary"));
      fadeIn(document.getElementById("settings"));
    });
    
    function getKnightMoveCells(cell) {
      let candidates = [];
      let row = Math.floor(cell / 3);
      let col = cell % 3;
      const moves = [ [2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2] ];
      moves.forEach(move => {
        let newRow = row + move[0];
        let newCol = col + move[1];
        if(newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3)
          candidates.push(newRow * 3 + newCol);
      });
      return candidates;
    }
    function isKnightMove(cellA, cellB) {
      return getKnightMoveCells(cellA).includes(cellB);
    }
    
    function populateDictionary() {
      const dictList = document.getElementById("dictionaryList");
      dictList.innerHTML = "";
      for (let i = 0; i < synesthesiaColors.length; i++) {
        const rowDiv = document.createElement("div");
        const colorBox = document.createElement("div");
        colorBox.className = "colorBox";
        colorBox.style.backgroundColor = synesthesiaColors[i];
        const toneButton = document.createElement("button");
        toneButton.textContent = "Play Tone";
        toneButton.addEventListener("click", () => { playTone(toneFrequencies[i], 1000); });
        rowDiv.appendChild(colorBox);
        rowDiv.appendChild(toneButton);
        dictList.appendChild(rowDiv);
      }
    }
    
    function drawGaborPatch(ctx, width, height, orientation, contrast, frequency) {
      let imageData = ctx.createImageData(width, height);
      let data = imageData.data;
      let cx = width / 2, cy = height / 2;
      let sigma = width / 6;
      let theta = orientation * Math.PI / 180;
      for (let y = 0; y < height; y++){
        for (let x = 0; x < width; x++){
          let x0 = x - cx, y0 = y - cy;
          let xr = x0 * Math.cos(theta) + y0 * Math.sin(theta);
          let grating = Math.cos(2 * Math.PI * frequency * xr);
          let gaussian = Math.exp(- (x0 * x0 + y0 * y0) / (2 * sigma * sigma));
          let value = contrast * grating * gaussian;
          let intensity = Math.round(128 + value * 127);
          let index = (y * width + x) * 4;
          data[index] = intensity;
          data[index+1] = intensity;
          data[index+2] = intensity;
          data[index+3] = 255;
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }
    
    
    function drawSynesthesiaStimulus(ctx, width, height, color) {
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, width, height);
    }
    
    function addPopAnimation(canvas) {
      canvas.classList.add("pop-animation");
      setTimeout(() => { canvas.classList.remove("pop-animation"); }, 400);
    }
    
    function pulseScore() {
      let scoreEl = document.getElementById("score");
      scoreEl.classList.add("score-pulse");
      setTimeout(() => { scoreEl.classList.remove("score-pulse"); }, 600);
    }
    
    // ========== UNIFIED SETTINGS INTEGRATION ==========
    // Auto-start game (bypass instructions)
    window.addEventListener('DOMContentLoaded', () => {
      document.getElementById("instructions").style.display = "none";
      fadeIn(document.getElementById("container"));
      fadeIn(document.getElementById("settings"));
    });
    
    // Listen for settings updates
    window.addEventListener('message', (event) => {
      if (event.data.type === 'settingsUpdate' && event.data.gameId === 'multiple') {
        const newSettings = event.data.settings;
        console.log('🎮 [Multiple] Received settings:', newSettings);
        
        Object.assign(settings, newSettings);
        
        const fields = ['modality', 'nValue', 'stimulusDuration', 'isiDuration', 'gaborContrast', 
                       'gaborFrequency', 'gaborSize', 'totalTrials', 'relationalComplexity'];
        fields.forEach(field => {
          const element = document.getElementById(field);
          if (field in newSettings && element) {
            element.value = newSettings[field];
          }
        });
        
        console.log('🎮 [Multiple] Settings applied');
      }
    });
    
    if (window.parent !== window) {
      window.parent.postMessage({ type: 'gameReady', gameId: 'multiple' }, '*');
    }
  </script>
</body>
</html>
