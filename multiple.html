<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Ensure proper scaling on all devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>N‑Back</title>
  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #000;
      --accent-color: #ffffff;
      --error-color: #d32f2f;
      --success-color: #27ae60;
      --text-color: #e0e0e0;
      --font: 'Audiowide', sans-serif;
      --transition-speed: 0.3s;
      --shadow: 0 2px 8px rgba(0,0,0,0.3);
      --progress-bg: rgba(255, 255, 255, 0.2);
    }
    /* Global Reset */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    /* Ripple Effect on Buttons */
    button { position: relative; overflow: hidden; }
    .ripple {
      position: absolute;
      width: 20px;
      height: 20px;
      background: rgba(255,255,255,0.5);
      border-radius: 50%;
      transform: scale(0);
      animation: rippleEffect 600ms linear;
      pointer-events: none;
    }
    @keyframes rippleEffect { to { transform: scale(4); opacity: 0; } }
    
    /* Body */
    body {
      background: linear-gradient(135deg, #1a1a1a, #0a0a0a);
      font-family: var(--font);
      color: var(--text-color);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    
    /* INSTRUCTIONS PANEL */
    #instructions {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30,30,30,0.98);
      border: 2px solid var(--accent-color);
      padding: 20px 30px;
      max-width: 90vw;
      max-height: 90vh;
      overflow-y: auto;
      z-index: 100;
      text-align: left;
      box-shadow: var(--shadow);
    }
    #instructions h1 {
      text-align: center;
      margin-bottom: 15px;
      font-size: 2.4rem;
      color: var(--accent-color);
    }
    #instructions p { margin-bottom: 10px; line-height: 1.6; font-size: 1rem; }
    #instructions button {
      display: block;
      margin: 20px auto 0;
      padding: 12px 24px;
      font-size: 1rem;
      background: var(--accent-color);
      color: #000;
      border: none;
      cursor: pointer;
      transition: background var(--transition-speed);
    }
    #instructions button:hover { background: var(--success-color); }
    
    /* MAIN CONTAINER – full width to fit at 100% zoom */
    #container {
      display: none;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      gap: 20px;
      padding: 20px;
    }
    
    /* SETTINGS PANEL */
    #settings {
      flex: 1 1 250px;
      background: rgba(30,30,30,0.98);
      padding: 20px;
      border: 2px solid var(--accent-color);
      box-shadow: var(--shadow);
    }
    #settings h2 {
      text-align: center;
      margin-bottom: 15px;
      font-size: 1.8rem;
      color: var(--accent-color);
      border-bottom: 1px solid var(--accent-color);
      padding-bottom: 10px;
    }
    #settings label { display: block; margin-bottom: 5px; font-size: 0.9rem; }
    #settings input, #settings select, #settings button {
      width: 100%;
      padding: 10px;
      margin-bottom: 15px;
      border: none;
      font-size: 1rem;
    }
    #settings input, #settings select { background: #111; color: var(--text-color); }
    #settings button { background: var(--accent-color); color: #000; cursor: pointer; transition: background 0.3s; }
    #settings button:hover { background: var(--success-color); }
    
    /* SYNESTHESIA DICTIONARY PANEL */
    #synesthesiaDictionary {
      display: none;
      background: rgba(30,30,30,0.98);
      padding: 20px;
      border: 2px solid var(--accent-color);
      box-shadow: var(--shadow);
      max-width: 600px;
      width: 100%;
    }
    #synesthesiaDictionary h2 { text-align: center; margin-bottom: 15px; color: var(--accent-color); }
    #dictionaryList { max-height: 400px; overflow-y: auto; padding-right: 5px; }
    #dictionaryList div { display: flex; align-items: center; margin-bottom: 10px; }
    #dictionaryList .colorBox { width: 40px; height: 40px; margin-right: 10px; border: 1px solid #fff; }
    #dictionaryList button {
      padding: 6px 10px;
      font-size: 0.9rem;
      background: var(--accent-color);
      color: #000;
      border: none;
      cursor: pointer;
      transition: background 0.3s;
    }
    #dictionaryList button:hover { background: var(--success-color); }
    #returnSettings {
      width: 100%;
      padding: 10px;
      font-size: 1rem;
      background: var(--accent-color);
      color: #000;
      border: none;
      cursor: pointer;
      transition: background 0.3s;
    }
    #returnSettings:hover { background: var(--success-color); }
    
    /* GAME PANEL */
    #game {
      display: none;
      flex: 2 1 600px;
      background: rgba(10,10,10,0.85);
      border-radius: 10px;
      padding: 20px;
      border: 2px solid var(--accent-color);
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
      max-width: 100vw;
    }
    
    /* Circuit Overlay - removed, using solid background */
    #circuitOverlay {
      display: none;
    }
    
    /* Progress Bar and Trial Progress */
    #progressBarContainer {
      width: 100%;
      background: var(--progress-bg);
      border-radius: 5px;
      margin-bottom: 5px;
      overflow: hidden;
      z-index: 2;
    }
    #progressBar {
      height: 8px;
      width: 0%;
      background: var(--accent-color);
      transition: width 0.5s ease-out;
    }
    #trialProgress {
      font-size: 1.2rem;
      margin-bottom: 10px;
      text-align: center;
      color: var(--accent-color);
      z-index: 2;
    }
    
    /* Score Streak Display Repositioned Below Progress Info */
    #streakDisplay {
      font-size: 1.2rem;
      color: var(--success-color);
      z-index: 2;
      margin: 10px 0;
      text-align: center;
    }
    
    /* Grid */
    #grid {
      position: relative;
      z-index: 1;
      width: fit-content;
      margin: 0 auto 20px auto;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      border: 2px solid var(--accent-color);
    }
    .grid-cell {
      background: #000;
      border: 2px solid var(--accent-color);
      box-shadow: var(--shadow);
      position: relative;
    }
    
    /* Controls */
    #controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 15px;
    }
    #controls button {
      padding: 12px 24px;
      font-size: 1rem;
      background: var(--error-color);
      color: #fff;
      border: none;
      cursor: pointer;
      transition: background 0.3s;
    }
    #controls button:hover { background: #c62828; }
    #visualMatch { display: none; }
    #showDictionary {
      display: none;
      padding: 12px 24px;
      font-size: 1rem;
      background: var(--accent-color);
      color: #000;
      border: none;
      cursor: pointer;
      transition: background 0.3s;
      margin-top: 10px;
    }
    #showDictionary:hover { background: var(--success-color); }
    
    /* Score Display */
    #score {
      font-size: 1.4rem;
      font-weight: bold;
      padding: 10px 20px;
      background: #1a1a1a;
      border: 2px solid var(--accent-color);
      box-shadow: var(--shadow);
      transition: transform 0.2s;
    }
    @keyframes pop {
      0% { transform: scale(0.9); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    .score-pulse {
      animation: pop 0.6s ease-out;
    }
    
    /* RESULTS PANEL */
    #results {
      display: none;
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30,30,30,0.98);
      padding: 30px;
      border: 2px solid var(--accent-color);
      box-shadow: var(--shadow);
      text-align: center;
      max-width: 600px;
      width: 90%;
      z-index: 200;
    }
    #results h2 {
      font-size: 2rem;
      color: var(--accent-color);
      margin-bottom: 20px;
    }
    #results p {
      font-size: 1.2rem;
      margin-bottom: 20px;
      animation: bounce 1s ease;
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    
    /* Robot Container */
    #robotContainer {
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 20px;
      flex-wrap: nowrap;
    }
    #robotImage { width: 120px; height: 180px; flex-shrink: 0; }
    #robotImage.happy { animation: happyNod 2s infinite; }
    @keyframes happyNod {
      0% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
      100% { transform: translateY(0); }
    }
    #robotImage.sad { animation: sadShake 2s infinite; }
    @keyframes sadShake {
      0% { transform: translateX(0); }
      25% { transform: translateX(-3px); }
      50% { transform: translateX(3px); }
      75% { transform: translateX(-3px); }
      100% { transform: translateX(0); }
    }
    #robotText {
      flex-grow: 1;
      padding-left: 20px;
      text-align: left;
      background: var(--accent-color);
      color: #000;
      padding: 10px 15px;
      font-size: 1rem;
      margin: 0;
      animation: fadeIn 0.5s ease-out;
    }
    
    /* Confetti */
    .confetti {
      position: absolute;
      width: 8px;
      height: 8px;
      opacity: 0.8;
      animation: confettiFall 2s linear forwards;
    }
    @keyframes confettiFall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(200px) rotate(360deg); opacity: 0; }
    }
    
    /* Pop Animation */
    .pop-animation { animation: pop 0.4s ease-out; }
    
    /* Glow Trail Effect */
    .glow-trail {
      position: absolute;
      background: radial-gradient(circle, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0) 70%);
      border-radius: 50%;
      pointer-events: none;
      transform: scale(1);
      animation: glowTrail 0.5s ease-out forwards;
    }
    @keyframes glowTrail {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(2.5); }
    }
    
    /* Fade In Animation */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
  </style>
</head>
<body>
  <!-- INSTRUCTIONS PANEL -->
  <div id="instructions">
    <h1>N‑Back</h1>
    <p>
      <strong>Modality Descriptions:</strong><br><br>
      <em>Gabor:</em> A Gabor patch appears in a random cell. Forced match trials repeat the orientation exactly from n‑back while appearing in a different cell.<br><br>
      <em>Circle (Knight’s Move):</em> A circle appears in a random cell. A match occurs if the current cell is reachable via a knight’s move from the n‑back cell. Additionally, in Circle mode you can press the "Visual Match" button to indicate an exact position match.<br><br>
      <em>Synesthesia:</em> Each trial randomly presents either a color or a sound. Twelve unique colors are paired with twelve distinct tone frequencies. N‑trials later, if the presented stimulus (regardless of modality) is the same as the one shown, that is a correct match.<br><br>
      <em>Relational Difference:</em> A number (0–99) is shown. For 1‑back, a match occurs if T(n) – T(n–1) = T(n–2) – T(n–3); for 2‑back, if T(n) – T(n–3) = T(n–2) – T(n–4).
    </p>
    <p>
      <strong>Instructions:</strong><br>
      Watch each stimulus carefully. When you believe the current stimulus matches the one shown n trials ago (according to the rules), press the "Match (n‑back)" button. In Circle mode you can also use the "Visual Match" button to indicate an exact position match. In Synesthesia mode, if the current stimulus (whether color or sound) corresponds to the one shown n trials ago, press "Match (n‑back)". Your score, progress, and current streak update automatically.
    </p>
    <button id="startInstructions">Begin</button>
  </div>
  
  <!-- MAIN CONTAINER -->
  <div id="container">
    <!-- SETTINGS PANEL -->
    <div id="settings">
      <h2>Settings</h2>
      <label for="modality">Select Modality:</label>
      <select id="modality">
        <option value="gabor">Gabor</option>
        <option value="circle">Circle (Knight’s Move)</option>
        <option value="synesthesia">Synesthesia</option>
        <option value="relational">Relational Difference</option>
      </select>
      <label for="nValue">N‑Back Value:</label>
      <input type="number" id="nValue" min="1" max="10" value="2">
      <label for="stimulusDuration">Stimulus Duration (ms):</label>
      <input type="number" id="stimulusDuration" min="100" max="2000" value="500">
      <label for="isiDuration">Inter‑Stimulus Interval (ms):</label>
      <input type="number" id="isiDuration" min="100" max="3000" value="1000">
      <div id="gaborParams">
        <label for="gaborContrast">Gabor Contrast (0 to 1):</label>
        <input type="range" id="gaborContrast" min="0" max="1" step="0.01" value="0.5">
        <label for="gaborFrequency">Gabor Spatial Frequency:</label>
        <input type="number" id="gaborFrequency" min="0.01" max="0.2" step="0.01" value="0.05">
      </div>
      <div id="relationalParams">
        <label for="relationalComplexity">Relational Complexity:</label>
        <select id="relationalComplexity">
          <option value="1back">1‑back</option>
          <option value="2back">2‑back</option>
        </select>
      </div>
      <label for="gaborSize">Stimulus Size (px):</label>
      <input type="number" id="gaborSize" min="50" max="300" value="150">
      <label for="totalTrials">Total Trials:</label>
      <input type="number" id="totalTrials" min="5" max="100" value="20">
      <button id="startTask">Start Task</button>
      <button id="showDictionary">Synesthesia Dictionary</button>
    </div>
    
    <!-- SYNESTHESIA DICTIONARY PANEL -->
    <div id="synesthesiaDictionary">
      <h2>Synesthesia Dictionary</h2>
      <div id="dictionaryList"></div>
      <button id="returnSettings">Return to Settings</button>
    </div>
    
    <!-- GAME PANEL -->
    <div id="game">
      <div id="circuitOverlay"></div>
      <div id="progressBarContainer">
        <div id="progressBar"></div>
      </div>
      <div id="trialProgress">Trial: 0 / 0</div>
      <!-- Score Streak Display -->
      <div id="streakDisplay">Streak: 0</div>
      <div id="grid">
        <canvas class="grid-cell" id="cell0"></canvas>
        <canvas class="grid-cell" id="cell1"></canvas>
        <canvas class="grid-cell" id="cell2"></canvas>
        <canvas class="grid-cell" id="cell3"></canvas>
        <canvas class="grid-cell" id="cell4"></canvas>
        <canvas class="grid-cell" id="cell5"></canvas>
        <canvas class="grid-cell" id="cell6"></canvas>
        <canvas class="grid-cell" id="cell7"></canvas>
        <canvas class="grid-cell" id="cell8"></canvas>
      </div>
      <div id="controls">
        <button id="restart">Restart</button>
        <button id="match">Match (n‑back)</button>
        <button id="visualMatch">Visual Match</button>
      </div>
      <div id="score">Score: 0</div>
    </div>
    
    <!-- RESULTS PANEL -->
    <div id="results">
      <div id="robotContainer">
        <div id="robotImage">
          <svg width="120" height="180" viewBox="0 0 120 180" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient id="robotBodyGradient" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%" stop-color="#555" />
                <stop offset="100%" stop-color="#222" />
              </linearGradient>
            </defs>
            <g id="head">
              <ellipse cx="60" cy="40" rx="30" ry="28" fill="#777" stroke="#00ffea" stroke-width="2"/>
              <circle cx="50" cy="35" r="5" fill="#00f">
                <animate attributeName="opacity" values="1;0.3;1" dur="1.2s" repeatCount="indefinite"/>
              </circle>
              <circle cx="70" cy="35" r="5" fill="#00f">
                <animate attributeName="opacity" values="1;0.3;1" dur="1.2s" begin="0.6s" repeatCount="indefinite"/>
              </circle>
              <path d="M45,50 Q60,60 75,50" stroke="#00ffea" stroke-width="3" fill="none"/>
            </g>
            <g id="body">
              <path d="M25,75 Q60,120 95,75 L95,150 Q60,170 25,150 Z" fill="url(#robotBodyGradient)" stroke="#00ffea" stroke-width="2"/>
            </g>
            <g id="arms">
              <line x1="25" y1="80" x2="5" y2="110" stroke="#00ffea" stroke-width="3"/>
              <line x1="95" y1="80" x2="115" y2="110" stroke="#00ffea" stroke-width="3"/>
            </g>
            <g id="legs">
              <rect x="40" y="150" width="15" height="25" fill="#777" stroke="#00ffea" stroke-width="2"/>
              <rect x="65" y="150" width="15" height="25" fill="#777" stroke="#00ffea" stroke-width="2"/>
            </g>
            <line x1="60" y1="10" x2="60" y2="30" stroke="#00ffea" stroke-width="2"/>
            <circle cx="60" cy="10" r="4" fill="#00ffea"/>
          </svg>
        </div>
        <div id="robotText">Great job!</div>
      </div>
      <h2>Task Complete!</h2>
      <p id="resultMessage"></p>
      <button id="playAgain">Play Again</button>
    </div>
  </div>
  
  <script>
    // Global Variables and Arrays
    let audioCtx = null;
    const toneFrequencies = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25, 587.33, 659.25, 739.99, 783.99];
    const synesthesiaColors = ["#FF0000", "#FF7F00", "#FFFF00", "#00FF00", "#00BFFF", "#0000FF", "#4B0082", "#8A2BE2", "#FF00FF", "#FFD700", "#FF1493", "#6A5ACD"];
    
    document.addEventListener("DOMContentLoaded", updateAdditionalParams);
    function updateAdditionalParams() {
      const mod = document.getElementById("modality").value;
      document.getElementById("gaborParams").style.display = (mod === "gabor") ? "block" : "none";
      document.getElementById("relationalParams").style.display = (mod === "relational") ? "block" : "none";
      document.getElementById("visualMatch").style.display = (mod === "circle") ? "inline-block" : "none";
      document.getElementById("showDictionary").style.display = (mod === "synesthesia") ? "inline-block" : "none";
    }
    
    function fadeIn(element) {
      element.style.opacity = 0;
      element.style.display = (element.id === "container") ? "flex" : "block";
      requestAnimationFrame(() => {
        element.style.transition = "opacity 0.5s ease";
        element.style.opacity = 1;
      });
    }
    function fadeOut(element) {
      element.style.transition = "opacity 0.5s ease";
      element.style.opacity = 0;
      setTimeout(() => {
        element.style.display = "none";
        element.style.transition = "";
      }, 500);
    }
    
    
    document.querySelectorAll("button").forEach(button => {
      button.addEventListener("click", function(e) {
        let ripple = document.createElement("span");
        ripple.className = "ripple";
        this.appendChild(ripple);
        const rect = this.getBoundingClientRect();
        ripple.style.left = (e.clientX - rect.left) + "px";
        ripple.style.top = (e.clientY - rect.top) + "px";
        setTimeout(() => { ripple.remove(); }, 600);
      });
    });
    
    let currentTrial = 0;
    let trialsData = [];
    let score = 0;
    let isRunning = false;
    let responseRecorded = false;
    let currentTrialData = null;
    let settings = {};
    let gridCanvases = [];
    let cellContexts = {};
    let stimulusTimeout = null;
    let trialTimeout = null;
    let currentStreak = 0;
    
    // For improved statistics, record "matchTrial" on match-intended trials.
    function computePossibleMatches() {
      let count = 0;
      for (let i = settings.nValue; i < trialsData.length; i++) {
        if (trialsData[i].matchTrial === true) count++;
      }
      return count;
    }
    
    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function getRandomIntNotEqual(min, max, exclude) {
      let rand;
      do { rand = getRandomInt(min, max); } while(rand === exclude);
      return rand;
    }
    
    // Glow trail effect for a grid cell
    function createGlowTrail(cell) {
      const trail = document.createElement("div");
      trail.className = "glow-trail";
      const gameRect = document.getElementById("game").getBoundingClientRect();
      const cellRect = cell.getBoundingClientRect();
      trail.style.width = cellRect.width + "px";
      trail.style.height = cellRect.height + "px";
      trail.style.top = (cellRect.top - gameRect.top) + "px";
      trail.style.left = (cellRect.left - gameRect.left) + "px";
      document.getElementById("game").appendChild(trail);
      setTimeout(() => { trail.remove(); }, 500);
    }
    
    function startTask() {
      settings = {
        modality: document.getElementById("modality").value,
        nValue: parseInt(document.getElementById("nValue").value),
        stimulusDuration: parseInt(document.getElementById("stimulusDuration").value),
        isiDuration: parseInt(document.getElementById("isiDuration").value),
        gaborContrast: parseFloat(document.getElementById("gaborContrast").value),
        gaborFrequency: parseFloat(document.getElementById("gaborFrequency").value),
        gaborSize: parseInt(document.getElementById("gaborSize").value),
        totalTrials: parseInt(document.getElementById("totalTrials").value)
      };
      if (settings.modality === "relational") {
        settings.relationalComplexity = document.getElementById("relationalComplexity").value;
      }
      gridCanvases = document.querySelectorAll(".grid-cell");
      gridCanvases.forEach(canvas => {
        canvas.width = settings.gaborSize;
        canvas.height = settings.gaborSize;
        cellContexts[canvas.id] = canvas.getContext("2d");
        canvas.style.borderColor = "#ffffff";
        canvas.style.backgroundColor = "#000";
      });
      document.getElementById("settings").style.display = "none";
      document.getElementById("synesthesiaDictionary").style.display = "none";
      document.getElementById("results").style.display = "none";
      document.getElementById("game").style.display = "flex";
      
      // Reset streak
      currentStreak = 0;
      updateStreakDisplay();
      
      currentTrial = 0;
      trialsData = [];
      score = 0;
      isRunning = true;
      responseRecorded = false;
      currentTrialData = null;
      clearTimeout(stimulusTimeout);
      clearTimeout(trialTimeout);
      stimulusTimeout = null;
      trialTimeout = null;
      document.getElementById("score").textContent = "Score: 0";
      updateProgressBar();
      if (audioCtx && audioCtx.state === "suspended") audioCtx.resume();
      nextTrial();
    }
    
    function updateStreakDisplay() {
      document.getElementById("streakDisplay").textContent = "Streak: " + currentStreak;
    }
    
    function updateProgressBar() {
      const progressBar = document.getElementById("progressBar");
      const percentage = (currentTrial / settings.totalTrials) * 100;
      progressBar.style.width = percentage + "%";
      document.getElementById("trialProgress").textContent = `Trial: ${currentTrial + 1} / ${settings.totalTrials}`;
    }
    
    function clearGrid() {
      gridCanvases.forEach(canvas => {
        let ctx = cellContexts[canvas.id];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      });
    }
    
    function nextTrial() {
      if (!isRunning) return;
      updateProgressBar();
      if (settings.modality === "gabor") nextTrialGabor();
      else if (settings.modality === "circle") nextTrialCircle();
      else if (settings.modality === "synesthesia") nextTrialSynesthesia();
      else if (settings.modality === "relational") nextTrialRelational();
    }
    
    function nextTrialGabor() {
      if (currentTrial >= settings.totalTrials) { endTask(); return; }
      clearTimeout(stimulusTimeout);
      clearTimeout(trialTimeout);
      clearGrid();
      let trial = {};
      if (currentTrial < settings.nValue) {
        trial.isMatch = false;
        trial.matchTrial = false;
        trial.cell = getRandomInt(0, 8);
        trial.orientation = Math.random() * 360;
      } else {
        let nBack = trialsData[currentTrial - settings.nValue];
        if (Math.random() < 0.40) {
          trial.isMatch = true;
          trial.matchTrial = true;
          trial.orientation = nBack.orientation;
          trial.cell = getRandomIntNotEqual(0, 8, nBack.cell);
        } else {
          trial.isMatch = false;
          trial.matchTrial = false;
          trial.orientation = Math.random() * 360;
          trial.cell = getRandomInt(0, 8);
        }
      }
      trialsData.push(trial);
      currentTrialData = trial;
      let canvas = document.getElementById("cell" + trial.cell);
      let ctx = cellContexts[canvas.id];
      drawGaborPatch(ctx, settings.gaborSize, settings.gaborSize, trial.orientation, settings.gaborContrast, settings.gaborFrequency);
      createGlowTrail(canvas);
      responseRecorded = false;
      canvas.classList.add("pop-animation");
      setTimeout(() => { canvas.classList.remove("pop-animation"); }, 400);
      stimulusTimeout = setTimeout(() => { clearGrid(); }, settings.stimulusDuration);
      trialTimeout = setTimeout(() => { currentTrial++; nextTrial(); }, settings.stimulusDuration + settings.isiDuration);
    }
    
    function nextTrialCircle() {
      if (currentTrial >= settings.totalTrials) { endTask(); return; }
      clearTimeout(stimulusTimeout);
      clearTimeout(trialTimeout);
      clearGrid();
      let trial = {};
      if (currentTrial < settings.nValue) {
        trial.isMatch = false;
        trial.matchTrial = false;
        trial.cell = getRandomInt(0, 8);
      } else {
        let nBack = trialsData[currentTrial - settings.nValue];
        if (Math.random() < 0.40) {
          if (Math.random() < 0.5) { trial.cell = nBack.cell; trial.isMatch = true; trial.matchTrial = true; }
          else {
            let candidates = getKnightMoveCells(nBack.cell);
            if (candidates.length > 0) { trial.cell = candidates[getRandomInt(0, candidates.length - 1)]; trial.isMatch = true; trial.matchTrial = true; }
            else { trial.cell = getRandomInt(0, 8); trial.isMatch = isKnightMove(nBack.cell, trial.cell); trial.matchTrial = trial.isMatch; }
          }
        } else {
          trial.cell = getRandomInt(0, 8);
          trial.isMatch = isKnightMove(nBack.cell, trial.cell);
          trial.matchTrial = trial.isMatch;
        }
      }
      trialsData.push(trial);
      currentTrialData = trial;
      let canvas = document.getElementById("cell" + trial.cell);
      let ctx = cellContexts[canvas.id];
      drawCircle(ctx, settings.gaborSize, settings.gaborSize);
      createGlowTrail(canvas);
      responseRecorded = false;
      canvas.classList.add("pop-animation");
      setTimeout(() => { canvas.classList.remove("pop-animation"); }, 400);
      stimulusTimeout = setTimeout(() => { clearGrid(); }, settings.stimulusDuration);
      trialTimeout = setTimeout(() => { currentTrial++; nextTrial(); }, settings.stimulusDuration + settings.isiDuration);
    }
    
    function nextTrialSynesthesia() {
      if (currentTrial >= settings.totalTrials) { endTask(); return; }
      clearTimeout(stimulusTimeout);
      clearTimeout(trialTimeout);
      clearGrid();
      let trial = {};
      trial.index = getRandomInt(0, 11);
      trial.stimulusType = (Math.random() < 0.5) ? "visual" : "auditory";
      if (currentTrial < settings.nValue) { trial.isMatch = false; trial.matchTrial = false; }
      else {
        let nBack = trialsData[currentTrial - settings.nValue];
        if (Math.random() < 0.40) { trial.isMatch = true; trial.matchTrial = true; trial.index = nBack.index; }
        else { trial.isMatch = false; trial.matchTrial = false; }
      }
      trialsData.push(trial);
      currentTrialData = trial;
      trial.cell = getRandomInt(0, 8);
      let canvas = document.getElementById("cell" + trial.cell);
      let ctx = cellContexts[canvas.id];
      if (trial.stimulusType === "visual") {
        ctx.fillStyle = synesthesiaColors[trial.index];
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        playTone(toneFrequencies[trial.index], settings.stimulusDuration);
      }
      createGlowTrail(canvas);
      responseRecorded = false;
      canvas.classList.add("pop-animation");
      setTimeout(() => { canvas.classList.remove("pop-animation"); }, 400);
      stimulusTimeout = setTimeout(() => { clearGrid(); }, settings.stimulusDuration);
      trialTimeout = setTimeout(() => { currentTrial++; nextTrial(); }, settings.stimulusDuration + settings.isiDuration);
    }
    
    function nextTrialRelational() {
      if (currentTrial >= settings.totalTrials) { endTask(); return; }
      clearTimeout(stimulusTimeout);
      clearTimeout(trialTimeout);
      clearGrid();
      let trial = {};
      if (settings.relationalComplexity === "1back") {
        if (currentTrial < settings.nValue + 1) { trial.isMatch = false; trial.matchTrial = false; trial.number = getRandomInt(0, 99); }
        else {
          if (Math.random() < 0.40) {
            trial.isMatch = true;
            trial.matchTrial = true;
            let computed = trialsData[currentTrial - 1].number + (trialsData[currentTrial - 2].number - trialsData[currentTrial - 3].number);
            computed = ((computed % 100) + 100) % 100;
            trial.number = computed;
          } else { trial.isMatch = false; trial.matchTrial = false; trial.number = getRandomInt(0, 99); }
        }
      } else if (settings.relationalComplexity === "2back") {
        if (currentTrial < settings.nValue + 2) { trial.isMatch = false; trial.matchTrial = false; trial.number = getRandomInt(0, 99); }
        else {
          if (Math.random() < 0.40) {
            trial.isMatch = true;
            trial.matchTrial = true;
            let computed = trialsData[currentTrial - 3].number + (trialsData[currentTrial - 2].number - trialsData[currentTrial - 4].number);
            computed = ((computed % 100) + 100) % 100;
            trial.number = computed;
          } else { trial.isMatch = false; trial.matchTrial = false; trial.number = getRandomInt(0, 99); }
        }
      }
      trial.cell = getRandomInt(0, 8);
      trialsData.push(trial);
      currentTrialData = trial;
      let canvas = document.getElementById("cell" + trial.cell);
      let ctx = cellContexts[canvas.id];
      ctx.fillStyle = "#ffffff";
      ctx.font = (settings.gaborSize * 0.8) + "px Audiowide, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(trial.number, canvas.width / 2, canvas.height / 2);
      createGlowTrail(canvas);
      responseRecorded = false;
      canvas.classList.add("pop-animation");
      setTimeout(() => { canvas.classList.remove("pop-animation"); }, 400);
      stimulusTimeout = setTimeout(() => { clearGrid(); }, settings.stimulusDuration);
      trialTimeout = setTimeout(() => { currentTrial++; nextTrial(); }, settings.stimulusDuration + settings.isiDuration);
    }
    
    function playTone(frequency, duration) {
      if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
      if (audioCtx.state === "suspended") audioCtx.resume();
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.frequency.value = frequency;
      oscillator.type = "sine";
      gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + 0.01);
      gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime + (duration/1000) - 0.05);
      gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + (duration/1000));
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.start();
      oscillator.stop(audioCtx.currentTime + (duration/1000) + 0.1);
    }
    
    function drawGaborPatch(ctx, width, height, orientation, contrast, frequency) {
      let imageData = ctx.createImageData(width, height);
      let data = imageData.data;
      let cx = width / 2, cy = height / 2;
      let sigma = width / 6;
      let theta = orientation * Math.PI / 180;
      for (let y = 0; y < height; y++){
        for (let x = 0; x < width; x++){
          let x0 = x - cx, y0 = y - cy;
          let xr = x0 * Math.cos(theta) + y0 * Math.sin(theta);
          let grating = Math.cos(2 * Math.PI * frequency * xr);
          let gaussian = Math.exp(- (x0 * x0 + y0 * y0) / (2 * sigma * sigma));
          let value = contrast * grating * gaussian;
          let intensity = Math.round(128 + value * 127);
          let index = (y * width + x) * 4;
          data[index] = intensity;
          data[index+1] = intensity;
          data[index+2] = intensity;
          data[index+3] = 255;
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }
    
    function drawCircle(ctx, width, height) {
      ctx.fillStyle = "#00ffea";
      let minR = width / 5, maxR = width / 3;
      let radius = minR + Math.random() * (maxR - minR);
      ctx.beginPath();
      ctx.arc(width/2, height/2, radius, 0, 2 * Math.PI);
      ctx.fill();
    }
    
    function drawSynesthesiaStimulus(ctx, width, height, color) {
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, width, height);
    }
    
    function addPopAnimation(canvas) {
      canvas.classList.add("pop-animation");
      setTimeout(() => { canvas.classList.remove("pop-animation"); }, 400);
    }
    
    function pulseScore() {
      let scoreEl = document.getElementById("score");
      scoreEl.classList.add("score-pulse");
      setTimeout(() => { scoreEl.classList.remove("score-pulse"); }, 600);
    }
    
    function playCorrectSound() {
      if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      osc.frequency.value = 800;
      osc.type = "sine";
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    }
    function playIncorrectSound() {
      if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      osc.frequency.value = 300;
      osc.type = "sine";
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.3);
    }
    
    function handleMatch() {
      if (responseRecorded || currentTrialData === null) return;
      responseRecorded = true;
      let feedbackCell = currentTrialData.cell;
      let correct = false;
      if (settings.modality === "gabor") {
        if (currentTrial >= settings.nValue) {
          if (currentTrialData.isMatch === true) correct = true;
        }
      } else {
        if (currentTrialData.isMatch === true) correct = true;
      }
      if (correct) {
        score++;
        currentStreak++;
        flashCell(feedbackCell, "#27ae60");
        pulseScore();
        if (settings.modality !== "synesthesia") { playCorrectSound(); }
      } else {
        currentStreak = 0;
        flashCell(feedbackCell, "#ff2d95");
        if (settings.modality !== "synesthesia") { playIncorrectSound(); }
      }
      updateStreakDisplay();
      document.getElementById("score").textContent = "Score: " + score;
    }
    
    function handleVisualMatch() {
      if (document.getElementById("modality").value !== "circle") return;
      if (responseRecorded || currentTrialData === null) return;
      responseRecorded = true;
      let nBack = trialsData[currentTrial - settings.nValue];
      let feedbackCell = currentTrialData.cell;
      let correct = false;
      if (currentTrial >= settings.nValue && currentTrialData.cell === nBack.cell) correct = true;
      if (correct) {
        score++;
        currentStreak++;
        flashCell(feedbackCell, "#27ae60");
        pulseScore();
        if (settings.modality !== "synesthesia") { playCorrectSound(); }
      } else {
        currentStreak = 0;
        flashCell(feedbackCell, "#ff2d95");
        if (settings.modality !== "synesthesia") { playIncorrectSound(); }
      }
      updateStreakDisplay();
      document.getElementById("score").textContent = "Score: " + score;
    }
    
    document.getElementById("match").addEventListener("click", handleMatch);
    document.getElementById("visualMatch").addEventListener("click", handleVisualMatch);
    
    function endTask() {
      isRunning = false;
      document.getElementById("game").style.display = "none";
      const resultsEl = document.getElementById("results");
      let possibleMatches = computePossibleMatches();
      let accuracyValue = possibleMatches > 0 ? (score / possibleMatches) * 100 : 0;
      let accuracyPercentage = possibleMatches > 0 ? accuracyValue.toFixed(0) : "N/A";
      const robotImage = document.getElementById("robotImage");
      robotImage.classList.remove("happy", "sad");
      if (accuracyValue >= 70) { robotImage.classList.add("happy"); }
      else if (accuracyValue < 40) { robotImage.classList.add("sad"); }
      let message = getEncouragement(accuracyValue);
      resultsEl.innerHTML = `
        <div id="robotContainer">
          <div id="robotImage">
            <svg width="120" height="180" viewBox="0 0 120 180" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <linearGradient id="robotBodyGradient" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="0%" stop-color="#555" />
                  <stop offset="100%" stop-color="#222" />
                </linearGradient>
              </defs>
              <g id="head">
                <ellipse cx="60" cy="40" rx="30" ry="28" fill="#777" stroke="#00ffea" stroke-width="2"/>
                <circle cx="50" cy="35" r="5" fill="#00f">
                  <animate attributeName="opacity" values="1;0.3;1" dur="1.2s" repeatCount="indefinite"/>
                </circle>
                <circle cx="70" cy="35" r="5" fill="#00f">
                  <animate attributeName="opacity" values="1;0.3;1" dur="1.2s" begin="0.6s" repeatCount="indefinite"/>
                </circle>
                <path d="M45,50 Q60,60 75,50" stroke="#00ffea" stroke-width="3" fill="none"/>
              </g>
              <g id="body">
                <path d="M25,75 Q60,120 95,75 L95,150 Q60,170 25,150 Z" fill="url(#robotBodyGradient)" stroke="#00ffea" stroke-width="2"/>
              </g>
              <g id="arms">
                <line x1="25" y1="80" x2="5" y2="110" stroke="#00ffea" stroke-width="3"/>
                <line x1="95" y1="80" x2="115" y2="110" stroke="#00ffea" stroke-width="3"/>
              </g>
              <g id="legs">
                <rect x="40" y="150" width="15" height="25" fill="#777" stroke="#00ffea" stroke-width="2"/>
                <rect x="65" y="150" width="15" height="25" fill="#777" stroke="#00ffea" stroke-width="2"/>
              </g>
              <line x1="60" y1="10" x2="60" y2="30" stroke="#00ffea" stroke-width="2"/>
              <circle cx="60" cy="10" r="4" fill="#00ffea"/>
            </svg>
          </div>
          <div id="robotText">${message}</div>
        </div>
        <h2>Task Complete!</h2>
        <p>Your Score: ${score} out of ${possibleMatches} possible matches.</p>
        <p>Accuracy: ${accuracyPercentage}%</p>
        <button id="playAgain">Play Again</button>
      `;
      resultsEl.style.display = "block";
      document.getElementById("playAgain").addEventListener("click", restartTask);
      if (accuracyValue >= 70) launchConfetti();
    }
    
    function getEncouragement(accuracy) {
      let highMessages = ["Outstanding! You're a genius!", "Amazing performance!", "Incredible!"];
      let mediumMessages = ["Great job! Keep pushing!", "Well done!", "Nice work!"];
      let lowMessages = ["Keep trying!", "Don't worry, practice makes perfect!", "You'll get there!"];
      if (accuracy >= 70) return highMessages[getRandomInt(0, highMessages.length - 1)];
      else if (accuracy >= 40) return mediumMessages[getRandomInt(0, mediumMessages.length - 1)];
      else return lowMessages[getRandomInt(0, lowMessages.length - 1)];
    }
    
    function launchConfetti() {
      const resultsEl = document.getElementById("results");
      let confettiContainer = document.createElement("div");
      confettiContainer.id = "confettiContainer";
      confettiContainer.style.position = "absolute";
      confettiContainer.style.top = "0";
      confettiContainer.style.left = "0";
      confettiContainer.style.width = "100%";
      confettiContainer.style.height = "100%";
      confettiContainer.style.pointerEvents = "none";
      resultsEl.appendChild(confettiContainer);
      const confettiCount = 20;
      for (let i = 0; i < confettiCount; i++) {
        let confetti = document.createElement("div");
        confetti.className = "confetti";
        confetti.style.left = Math.random() * 100 + "%";
        confetti.style.animationDelay = Math.random() * 0.5 + "s";
        const confettiColors = ["#FF7F00", "#FFFF00", "#00FF00", "#00BFFF", "#FF00FF", "#FFD700"];
        confetti.style.backgroundColor = confettiColors[getRandomInt(0, confettiColors.length - 1)];
        confettiContainer.appendChild(confetti);
      }
      setTimeout(() => { resultsEl.removeChild(confettiContainer); }, 3000);
    }
    
    function flashCell(cellIndex, color) {
      let canvas = document.getElementById("cell" + cellIndex);
      canvas.style.borderColor = color;
      setTimeout(() => { canvas.style.borderColor = "#ffffff"; }, 300);
    }
    
    function restartTask() {
      isRunning = false;
      currentTrial = 0;
      trialsData = [];
      score = 0;
      currentStreak = 0;
      updateStreakDisplay();
      document.getElementById("score").textContent = "Score: 0";
      document.getElementById("synesthesiaDictionary").style.display = "none";
      document.getElementById("game").style.display = "none";
      document.getElementById("results").style.display = "none";
      document.getElementById("settings").style.display = "block";
      updateAdditionalParams();
      clearGrid();
      clearTimeout(stimulusTimeout);
      clearTimeout(trialTimeout);
      stimulusTimeout = null;
      trialTimeout = null;
    }
    
    document.getElementById("startInstructions").addEventListener("click", () => {
      fadeOut(document.getElementById("instructions"));
      fadeIn(document.getElementById("container"));
      fadeIn(document.getElementById("settings"));
      document.getElementById("game").style.display = "none";
      document.getElementById("results").style.display = "none";
      updateAdditionalParams();
    });
    document.getElementById("startTask").addEventListener("click", startTask);
    document.getElementById("restart").addEventListener("click", restartTask);
    document.getElementById("match").addEventListener("click", handleMatch);
    document.getElementById("playAgain").addEventListener("click", restartTask);
    document.getElementById("modality").addEventListener("change", updateAdditionalParams);
    document.getElementById("showDictionary").addEventListener("click", () => {
      fadeOut(document.getElementById("settings"));
      fadeIn(document.getElementById("synesthesiaDictionary"));
      populateDictionary();
    });
    document.getElementById("returnSettings").addEventListener("click", () => {
      fadeOut(document.getElementById("synesthesiaDictionary"));
      fadeIn(document.getElementById("settings"));
    });
    
    function getKnightMoveCells(cell) {
      let candidates = [];
      let row = Math.floor(cell / 3);
      let col = cell % 3;
      const moves = [ [2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2] ];
      moves.forEach(move => {
        let newRow = row + move[0];
        let newCol = col + move[1];
        if(newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3)
          candidates.push(newRow * 3 + newCol);
      });
      return candidates;
    }
    function isKnightMove(cellA, cellB) {
      return getKnightMoveCells(cellA).includes(cellB);
    }
    
    function populateDictionary() {
      const dictList = document.getElementById("dictionaryList");
      dictList.innerHTML = "";
      for (let i = 0; i < synesthesiaColors.length; i++) {
        const rowDiv = document.createElement("div");
        const colorBox = document.createElement("div");
        colorBox.className = "colorBox";
        colorBox.style.backgroundColor = synesthesiaColors[i];
        const toneButton = document.createElement("button");
        toneButton.textContent = "Play Tone";
        toneButton.addEventListener("click", () => { playTone(toneFrequencies[i], 1000); });
        rowDiv.appendChild(colorBox);
        rowDiv.appendChild(toneButton);
        dictList.appendChild(rowDiv);
      }
    }
    
    function drawGaborPatch(ctx, width, height, orientation, contrast, frequency) {
      let imageData = ctx.createImageData(width, height);
      let data = imageData.data;
      let cx = width / 2, cy = height / 2;
      let sigma = width / 6;
      let theta = orientation * Math.PI / 180;
      for (let y = 0; y < height; y++){
        for (let x = 0; x < width; x++){
          let x0 = x - cx, y0 = y - cy;
          let xr = x0 * Math.cos(theta) + y0 * Math.sin(theta);
          let grating = Math.cos(2 * Math.PI * frequency * xr);
          let gaussian = Math.exp(- (x0 * x0 + y0 * y0) / (2 * sigma * sigma));
          let value = contrast * grating * gaussian;
          let intensity = Math.round(128 + value * 127);
          let index = (y * width + x) * 4;
          data[index] = intensity;
          data[index+1] = intensity;
          data[index+2] = intensity;
          data[index+3] = 255;
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }
    
    function drawCircle(ctx, width, height) {
      ctx.fillStyle = "#00ffea";
      let minR = width / 5, maxR = width / 3;
      let radius = minR + Math.random() * (maxR - minR);
      ctx.beginPath();
      ctx.arc(width/2, height/2, radius, 0, 2 * Math.PI);
      ctx.fill();
    }
    
    function drawSynesthesiaStimulus(ctx, width, height, color) {
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, width, height);
    }
    
    function addPopAnimation(canvas) {
      canvas.classList.add("pop-animation");
      setTimeout(() => { canvas.classList.remove("pop-animation"); }, 400);
    }
    
    function pulseScore() {
      let scoreEl = document.getElementById("score");
      scoreEl.classList.add("score-pulse");
      setTimeout(() => { scoreEl.classList.remove("score-pulse"); }, 600);
    }
  </script>
</body>
</html>
